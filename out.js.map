{"version":3,"file":"out.js","sources":["../node_modules/solid-js/dist/solid.js","../node_modules/solid-js/web/dist/web.js","../src/utils.tsx","../src/index.tsx"],"sourcesContent":["let taskIdCounter = 1,\n    isCallbackScheduled = false,\n    isPerformingWork = false,\n    taskQueue = [],\n    currentTask = null,\n    shouldYieldToHost = null,\n    yieldInterval = 5,\n    deadline = 0,\n    maxYieldInterval = 300,\n    scheduleCallback = null,\n    scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n        port = channel.port2;\n  scheduleCallback = () => port.postMessage(null);\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n    while (m <= n) {\n      const k = n + m >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;\n    }\n    return m;\n  }\n  taskQueue.splice(findIndex(), 0, task);\n}\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n      timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n  return newTask;\n}\nfunction cancelCallback(task) {\n  task.fn = null;\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n    const callback = currentTask.fn;\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n    currentTask = taskQueue[0] || null;\n  }\n  return currentTask !== null;\n}\n\nconst sharedConfig = {};\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nfunction nextHydrateContext() {\n  return { ...sharedConfig.context,\n    id: `${sharedConfig.context.id}${sharedConfig.context.count++}.`,\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst NOTPENDING = {};\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst [transPending, setTransPending] = /*@__PURE__*/createSignal(false);\nvar Owner = null;\nlet Transition = null;\nlet Listener = null;\nlet Pending = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  detachedOwner && (Owner = detachedOwner);\n  const listener = Listener,\n        owner = Owner,\n        root = fn.length === 0 && !false ? UNOWNED : {\n    owned: null,\n    cleanups: null,\n    context: null,\n    owner\n  };\n  Owner = root;\n  Listener = null;\n  let result;\n  try {\n    runUpdates(() => result = fn(() => cleanNode(root)), true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n  return result;\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    pending: NOTPENDING,\n    comparator: options.equals || undefined\n  };\n  return [readSignal.bind(s), value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.pending !== NOTPENDING ? s.pending : s.tValue);else value = value(s.pending !== NOTPENDING ? s.pending : s.value);\n    }\n    return writeSignal(s, value);\n  }];\n}\nfunction createComputed(fn, value, options) {\n  updateComputation(createComputation(fn, value, true));\n}\nfunction createRenderEffect(fn, value, options) {\n  updateComputation(createComputation(fn, value, false));\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  Effects && Effects.push(c);\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true);\n  c.pending = NOTPENDING;\n  c.observers = null;\n  c.observerSlots = null;\n  c.state = 0;\n  c.comparator = options.equals || undefined;\n  updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction createResource(source, fetcher, options = {}) {\n  if (arguments.length === 2) {\n    if (typeof fetcher === \"object\") {\n      options = fetcher;\n      fetcher = source;\n      source = true;\n    }\n  } else if (arguments.length === 1) {\n    fetcher = source;\n    source = true;\n  }\n  const contexts = new Set(),\n        [s, set] = createSignal(options.initialValue),\n        [track, trigger] = createSignal(undefined, {\n    equals: false\n  }),\n        [loading, setLoading] = createSignal(false),\n        [error, setError] = createSignal();\n  let err = undefined,\n      pr = null,\n      initP = null,\n      id = null,\n      loadedUnderTransition = false,\n      dynamic = typeof source === \"function\";\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n    if (sharedConfig.context.loadResource) {\n      initP = sharedConfig.context.loadResource(id);\n    } else if (sharedConfig.resources && id && id in sharedConfig.resources) {\n      initP = sharedConfig.resources[id];\n      delete sharedConfig.resources[id];\n    }\n  }\n  function loadEnd(p, v, e) {\n    if (pr === p) {\n      setError(err = e);\n      pr = null;\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n          if (!Transition.promises.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n          completeLoad(v);\n        }, false);\n      } else completeLoad(v);\n    }\n    return v;\n  }\n  function completeLoad(v) {\n    batch(() => {\n      set(() => v);\n      setLoading(false);\n      for (const c of contexts.keys()) c.decrement();\n      contexts.clear();\n    });\n  }\n  function read() {\n    const c = SuspenseContext && lookup(Owner, SuspenseContext.id),\n          v = s();\n    if (err) throw err;\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c.resolved && Transition) Transition.promises.add(pr);else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load() {\n    setError(err = undefined);\n    const lookup = dynamic ? source() : source;\n    loadedUnderTransition = Transition && Transition.running;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(s));\n      return;\n    }\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p = initP || untrack(() => fetcher(lookup, s));\n    initP = null;\n    if (typeof p !== \"object\" || !(\"then\" in p)) {\n      loadEnd(pr, p);\n      return;\n    }\n    pr = p;\n    batch(() => {\n      setLoading(true);\n      trigger();\n    });\n    p.then(v => loadEnd(p, v), e => loadEnd(p, e, e));\n  }\n  Object.defineProperties(read, {\n    loading: {\n      get() {\n        return loading();\n      }\n    },\n    error: {\n      get() {\n        return error();\n      }\n    }\n  });\n  if (dynamic) createComputed(load);else load();\n  return [read, {\n    refetch: load,\n    mutate: set\n  }];\n}\nfunction createDeferred(source, options) {\n  let t,\n      timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(() => {\n    if (!t || !t.fn) t = requestCallback(() => setDeferred(() => node.value), timeout !== undefined ? {\n      timeout\n    } : undefined);\n    return source();\n  }, undefined, true);\n  const [deferred, setDeferred] = createSignal(node.value, options);\n  updateComputation(node);\n  setDeferred(() => node.value);\n  return deferred;\n}\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(p => {\n    const v = source();\n    for (const key of subs.keys()) if (fn(key, v) || p !== undefined && fn(key, p)) {\n      const l = subs.get(key);\n      for (const c of l.values()) {\n        c.state = STALE;\n        if (c.pure) Updates.push(c);else Effects.push(c);\n      }\n    }\n    return v;\n  }, undefined, true);\n  updateComputation(node);\n  return key => {\n    let listener;\n    if (listener = Listener) {\n      let l;\n      if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));\n      onCleanup(() => {\n        l.size > 1 ? l.delete(listener) : subs.delete(key);\n      });\n    }\n    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);\n  };\n}\nfunction batch(fn) {\n  if (Pending) return fn();\n  let result;\n  const q = Pending = [];\n  try {\n    result = fn();\n  } finally {\n    Pending = null;\n  }\n  runUpdates(() => {\n    for (let i = 0; i < q.length; i += 1) {\n      const data = q[i];\n      if (data.pending !== NOTPENDING) {\n        const pending = data.pending;\n        data.pending = NOTPENDING;\n        writeSignal(data, pending);\n      }\n    }\n  }, false);\n  return result;\n}\nfunction untrack(fn) {\n  let result,\n      listener = Listener;\n  Listener = null;\n  result = fn();\n  Listener = listener;\n  return result;\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n    if (isArray) {\n      input = [];\n      for (let i = 0; i < deps.length; i++) input.push(deps[i]());\n    } else input = deps();\n    if (defer) {\n      defer = false;\n      return undefined;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null) ;else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null) ;else if (Owner.context === null) Owner.context = {\n    [ERROR]: [fn]\n  };else if (!Owner.context[ERROR]) Owner.context[ERROR] = [fn];else Owner.context[ERROR].push(fn);\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  Owner = o;\n  try {\n    return fn();\n  } finally {\n    Owner = prev;\n  }\n}\nfunction useTransition() {\n  return [transPending, (fn, cb) => {\n    if (SuspenseContext) {\n      Transition || (Transition = {\n        sources: new Set(),\n        effects: [],\n        promises: new Set(),\n        disposed: new Set(),\n        running: true,\n        cb: []\n      });\n      cb && Transition.cb.push(cb);\n      Transition.running = true;\n    }\n    batch(fn);\n    if (!SuspenseContext && cb) cb();\n  }];\n}\nfunction resumeEffects(e) {\n  Transition && (Transition.running = true);\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\nfunction createContext(defaultValue) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  return lookup(Owner, context.id) || context.defaultValue;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  return createMemo(() => resolveChildren(children()));\n}\nlet SuspenseContext;\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext({}));\n}\nfunction readSignal() {\n  if (this.state && this.sources) {\n    const updates = Updates;\n    Updates = null;\n    this.state === STALE ? updateComputation(this) : lookDownstream(this);\n    Updates = updates;\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  if (Transition && Transition.running && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  if (node.comparator) {\n    if (Transition && Transition.running && Transition.sources.has(node)) {\n      if (node.comparator(node.tValue, value)) return value;\n    } else if (node.comparator(node.value, value)) return value;\n  }\n  if (Pending) {\n    if (node.pending === NOTPENDING) Pending.push(node);\n    node.pending = value;\n    return value;\n  }\n  if (Transition) {\n    if (Transition.running || !isComp && Transition.sources.has(node)) {\n      Transition.sources.add(node);\n      node.tValue = value;\n    }\n    if (!Transition.running) node.value = value;\n  } else node.value = value;\n  if (node.observers && (!Updates || node.observers.length)) {\n    runUpdates(() => {\n      for (let i = 0; i < node.observers.length; i += 1) {\n        const o = node.observers[i];\n        if (Transition && Transition.running && Transition.disposed.has(o)) continue;\n        if (o.observers && o.state !== PENDING) markUpstream(o);\n        o.state = STALE;\n        if (o.pure) Updates.push(o);else Effects.push(o);\n      }\n      if (Updates.length > 10e5) {\n        Updates = [];\n        if (false) ;\n        throw new Error();\n      }\n    }, false);\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const owner = Owner,\n        listener = Listener,\n        time = ExecCount;\n  Listener = Owner = node;\n  runComputation(node, node.value, time);\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    Transition.running = true;\n    runComputation(node, node.tValue, time);\n    Transition.running = false;\n  }\n  Listener = listener;\n  Owner = owner;\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    handleError(err);\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.observers && node.observers.length) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, options) {\n  const c = {\n    fn,\n    state: STALE,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: null,\n    pure\n  };\n  if (Owner === null) ;else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);\n    }\n  }\n  return c;\n}\nfunction runTop(node) {\n  let top = node.state === STALE && node,\n      pending = [];\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const runningTransition = Transition && Transition.running;\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (node.state === PENDING) pending.push(node);else if (node.state === STALE) {\n      top = node;\n      pending = [];\n    }\n  }\n  if (pending.length) {\n    for (let i = pending.length - 1; i >= 0; i--) {\n      const updates = Updates;\n      Updates = null;\n      lookDownstream(pending[i]);\n      Updates = updates;\n    }\n    if (!top || top.state !== STALE) return;\n    if (runningTransition) {\n      node = top;\n      while (node = node.owner) {\n        if (Transition.disposed.has(node)) return;\n      }\n    }\n  }\n  top && updateComputation(top);\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;else Effects = [];\n  ExecCount++;\n  try {\n    fn();\n  } catch (err) {\n    handleError(err);\n  } finally {\n    completeUpdates(wait);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  let cbs;\n  if (Transition && Transition.running) {\n    if (Transition.promises.size) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n    const sources = Transition.sources;\n    cbs = Transition.cb;\n    Transition = null;\n    batch(() => {\n      sources.forEach(v => {\n        v.value = v.tValue;\n        if (v.owned) {\n          for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n        }\n        if (v.tOwned) v.owned = v.tOwned;\n        delete v.tValue;\n        delete v.tOwned;\n      });\n      setTransPending(false);\n    });\n  }\n  if (Effects.length) batch(() => {\n    runEffects(Effects);\n    Effects = null;\n  });else {\n    Effects = null;\n  }\n  if (cbs) cbs.forEach(cb => cb());\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction runUserEffects(queue) {\n  let i,\n      userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);else queue[userLength++] = e;\n  }\n  const resume = queue.length;\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n  for (i = resume; i < queue.length; i++) runTop(queue[i]);\n}\nfunction lookDownstream(node) {\n  node.state = 0;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      if (source.state === STALE) runTop(source);else if (source.state === PENDING) lookDownstream(source);\n    }\n  }\n}\nfunction markUpstream(node) {\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (!o.state) {\n      o.state = PENDING;\n      o.observers && markUpstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n            index = node.sourceSlots.pop(),\n            obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n              s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (Transition && Transition.running && node.pure) {\n    if (node.tOwned) {\n      for (i = 0; i < node.tOwned.length; i++) cleanNode(node.tOwned[i]);\n      delete node.tOwned;\n    }\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = 0; i < node.owned.length; i++) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = 0; i < node.cleanups.length; i++) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  node.state = 0;\n  node.context = null;\n}\nfunction reset(node, top) {\n  if (!top) {\n    node.state = 0;\n    Transition.disposed.add(node);\n  }\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\nfunction handleError(err) {\n  const fns = ERROR && lookup(Owner, ERROR);\n  if (!fns) throw err;\n  fns.forEach(f => f(err));\n}\nfunction lookup(owner, key) {\n  return owner && (owner.context && owner.context[key] || owner.owner && lookup(owner.owner, key));\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\nfunction createProvider(id) {\n  return function provider(props) {\n    let res;\n    createComputed(() => res = untrack(() => {\n      Owner.context = {\n        [id]: props.value\n      };\n      return children(() => props.children);\n    }));\n    return res;\n  };\n}\n\nfunction getSymbol() {\n  const SymbolCopy = Symbol;\n  return SymbolCopy.observable || '@@observable';\n}\nfunction observable(input) {\n  const $$observable = getSymbol();\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n      const handler = \"next\" in observer ? observer.next : observer;\n      let complete = false;\n      createComputed(() => {\n        if (complete) return;\n        const v = input();\n        untrack(() => handler(v));\n      });\n      return {\n        unsubscribe() {\n          complete = true;\n        }\n      };\n    },\n    [$$observable]() {\n      return this;\n    }\n  };\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      len = 0,\n      indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n        i,\n        j;\n    return untrack(() => {\n      let newLen = newItems.length,\n          newIndices,\n          newIndicesNext,\n          temp,\n          tempdisposers,\n          tempIndexes,\n          start,\n          end,\n          newEnd,\n          item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      }\n      else if (len === 0) {\n          mapped = new Array(newLen);\n          for (j = 0; j < newLen; j++) {\n            items[j] = newItems[j];\n            mapped[j] = createRoot(mapper);\n          }\n          len = newLen;\n        } else {\n          temp = new Array(newLen);\n          tempdisposers = new Array(newLen);\n          indexes && (tempIndexes = new Array(newLen));\n          for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);\n          for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n            temp[newEnd] = mapped[end];\n            tempdisposers[newEnd] = disposers[end];\n            indexes && (tempIndexes[newEnd] = indexes[end]);\n          }\n          newIndices = new Map();\n          newIndicesNext = new Array(newEnd + 1);\n          for (j = newEnd; j >= start; j--) {\n            item = newItems[j];\n            i = newIndices.get(item);\n            newIndicesNext[j] = i === undefined ? -1 : i;\n            newIndices.set(item, j);\n          }\n          for (i = start; i <= end; i++) {\n            item = items[i];\n            j = newIndices.get(item);\n            if (j !== undefined && j !== -1) {\n              temp[j] = mapped[i];\n              tempdisposers[j] = disposers[i];\n              indexes && (tempIndexes[j] = indexes[i]);\n              j = newIndicesNext[j];\n              newIndices.set(item, j);\n            } else disposers[i]();\n          }\n          for (j = start; j < newLen; j++) {\n            if (j in temp) {\n              mapped[j] = temp[j];\n              disposers[j] = tempdisposers[j];\n              if (indexes) {\n                indexes[j] = tempIndexes[j];\n                indexes[j](j);\n              }\n            } else mapped[j] = createRoot(mapper);\n          }\n          mapped = mapped.slice(0, len = newLen);\n          items = newItems.slice(0);\n        }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      signals = [],\n      len = 0,\n      i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return mapped = mapped.slice(0, len);\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nfunction createComponent(Comp, props) {\n  if (sharedConfig.context) {\n    const c = sharedConfig.context;\n    setHydrateContext(nextHydrateContext());\n    const r = untrack(() => Comp(props));\n    setHydrateContext(c);\n    return r;\n  }\n  return untrack(() => Comp(props));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction mergeProps(...sources) {\n  return new Proxy({\n    get(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        const v = sources[i][property];\n        if (v !== undefined) return v;\n      }\n    },\n    has(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        if (property in sources[i]) return true;\n      }\n      return false;\n    },\n    keys() {\n      const keys = [];\n      for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(sources[i]));\n      return [...new Set(keys)];\n    }\n  }, propTraps);\n}\nfunction splitProps(props, ...keys) {\n  const blocked = new Set(keys.flat());\n  const descriptors = Object.getOwnPropertyDescriptors(props);\n  const res = keys.map(k => {\n    const clone = {};\n    for (let i = 0; i < k.length; i++) {\n      const key = k[i];\n      Object.defineProperty(clone, key, descriptors[key] ? descriptors[key] : {\n        get() {\n          return props[key];\n        }\n      });\n    }\n    return clone;\n  });\n  res.push(new Proxy({\n    get(property) {\n      return blocked.has(property) ? undefined : props[property];\n    },\n    has(property) {\n      return blocked.has(property) ? false : property in props;\n    },\n    keys() {\n      return Object.keys(props).filter(k => !blocked.has(k));\n    }\n  }, propTraps));\n  return res;\n}\nfunction lazy(fn) {\n  let comp;\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n    if (ctx && sharedConfig.resources) {\n      ctx.count++;\n      const [s, set] = createSignal();\n      fn().then(mod => {\n        setHydrateContext(ctx);\n        set(() => mod.default);\n        setHydrateContext(undefined);\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => fn().then(mod => mod.default));\n      comp = s;\n    } else {\n      const c = comp();\n      if (c) return c(props);\n    }\n    let Comp;\n    return createMemo(() => (Comp = comp()) && untrack(() => {\n      if (!ctx) return Comp(props);\n      const c = sharedConfig.context;\n      setHydrateContext(ctx);\n      const r = Comp(props);\n      setHydrateContext(c);\n      return r;\n    }));\n  };\n  wrap.preload = () => comp || fn().then(mod => comp = () => mod.default);\n  return wrap;\n}\n\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Show(props) {\n  let strictEqual = false;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => strictEqual ? a === b : !a === !b\n  });\n  return createMemo(() => {\n    const c = condition();\n    if (c) {\n      const child = props.children;\n      return (strictEqual = typeof child === \"function\" && child.length > 0) ? untrack(() => child(c)) : child;\n    }\n    return props.fallback;\n  });\n}\nfunction Switch(props) {\n  let strictEqual = false;\n  const conditions = children(() => props.children),\n        evalConditions = createMemo(() => {\n    let conds = conditions();\n    if (!Array.isArray(conds)) conds = [conds];\n    for (let i = 0; i < conds.length; i++) {\n      const c = conds[i].when;\n      if (c) return [i, c, conds[i]];\n    }\n    return [-1];\n  }, undefined, {\n    equals: (a, b) => a && a[0] === b[0] && (strictEqual ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2]\n  });\n  return createMemo(() => {\n    const [index, when, cond] = evalConditions();\n    if (index < 0) return props.fallback;\n    const c = cond.children;\n    return (strictEqual = typeof c === \"function\" && c.length > 0) ? untrack(() => c(when)) : c;\n  });\n}\nfunction Match(props) {\n  return props;\n}\nfunction ErrorBoundary(props) {\n  const [errored, setErrored] = createSignal();\n  onError(setErrored);\n  let e;\n  return createMemo(() => {\n    if ((e = errored()) != null) {\n      const f = props.fallback;\n      return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored(null))) : f;\n    }\n    return props.children;\n  });\n}\n\nconst SuspenseListContext = createContext();\nfunction SuspenseList(props) {\n  let index = 0,\n      suspenseSetter,\n      showContent,\n      showFallback;\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) {\n    const [inFallback, setFallback] = createSignal(false);\n    suspenseSetter = setFallback;\n    [showContent, showFallback] = listContext.register(inFallback);\n  }\n  const registry = [],\n        comp = createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        const [showingContent, showContent] = createSignal(false),\n              [showingFallback, showFallback] = createSignal(false);\n        registry[index++] = {\n          inFallback,\n          showContent,\n          showFallback\n        };\n        return [showingContent, showingFallback];\n      }\n    },\n    get children() {\n      return props.children;\n    }\n  });\n  createComputed(() => {\n    const reveal = props.revealOrder,\n          tail = props.tail,\n          visibleContent = showContent ? showContent() : true,\n          visibleFallback = showFallback ? showFallback() : true,\n          reverse = reveal === \"backwards\";\n    if (reveal === \"together\") {\n      const all = registry.every(i => !i.inFallback());\n      suspenseSetter && suspenseSetter(!all);\n      registry.forEach(i => {\n        i.showContent(all && visibleContent);\n        i.showFallback(visibleFallback);\n      });\n      return;\n    }\n    let stop = false;\n    for (let i = 0, len = registry.length; i < len; i++) {\n      const n = reverse ? len - i - 1 : i,\n            s = registry[n].inFallback();\n      if (!stop && !s) {\n        registry[n].showContent(visibleContent);\n        registry[n].showFallback(visibleFallback);\n      } else {\n        const next = !stop;\n        if (next && suspenseSetter) suspenseSetter(true);\n        if (!tail || next && tail === \"collapsed\") {\n          registry[n].showFallback(visibleFallback);\n        } else registry[n].showFallback(false);\n        stop = true;\n        registry[n].showContent(next);\n      }\n    }\n    if (!stop && suspenseSetter) suspenseSetter(false);\n  });\n  return comp;\n}\nfunction Suspense(props) {\n  let counter = 0,\n      showContent,\n      showFallback;\n  const [inFallback, setFallback] = createSignal(false),\n        SuspenseContext = getSuspenseContext(),\n        store = {\n    increment: () => {\n      if (++counter === 1) setFallback(true);\n    },\n    decrement: () => {\n      if (--counter === 0) setFallback(false);\n    },\n    inFallback,\n    effects: [],\n    resolved: false\n  };\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) [showContent, showFallback] = listContext.register(store.inFallback);\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n    get children() {\n      const rendered = untrack(() => props.children);\n      return createMemo(() => {\n        const inFallback = store.inFallback(),\n              visibleContent = showContent ? showContent() : true,\n              visibleFallback = showFallback ? showFallback() : true;\n        if (!inFallback && visibleContent) {\n          store.resolved = true;\n          resumeEffects(store.effects);\n          return rendered;\n        }\n        if (!visibleFallback) return;\n        return props.fallback;\n      });\n    }\n  });\n}\n\nfunction awaitSuspense() {}\nlet DEV;\n\nexport { $PROXY, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, awaitSuspense, batch, cancelCallback, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createRenderEffect, createResource, createRoot, createSelector, createSignal, equalFn, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, requestCallback, runWithOwner, sharedConfig, splitProps, untrack, useContext, useTransition };\n","import { createMemo, createRoot, createRenderEffect, sharedConfig, createSignal, onCleanup, splitProps, untrack } from 'solid-js';\nexport { ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, createComponent, createRenderEffect as effect, getOwner, mergeProps } from 'solid-js';\n\nconst booleans = [\"allowfullscreen\", \"allowpaymentrequest\", \"async\", \"autofocus\", \"autoplay\", \"checked\", \"controls\", \"default\", \"disabled\", \"formnovalidate\", \"hidden\", \"ismap\", \"itemscope\", \"loop\", \"multiple\", \"muted\", \"nomodule\", \"novalidate\", \"open\", \"playsinline\", \"readonly\", \"required\", \"reversed\", \"seamless\", \"selected\", \"truespeed\"];\nconst Properties = new Set([\"className\", \"indeterminate\", \"value\", ...booleans]);\nconst ChildProperties = new Set([\"innerHTML\", \"textContent\", \"innerText\", \"children\"]);\nconst Aliases = {\n  className: \"class\",\n  htmlFor: \"for\"\n};\nconst DelegatedEvents = new Set([\"beforeinput\", \"click\", \"dblclick\", \"focusin\", \"focusout\", \"input\", \"keydown\", \"keyup\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"pointerdown\", \"pointermove\", \"pointerout\", \"pointerover\", \"pointerup\", \"touchend\", \"touchmove\", \"touchstart\"]);\nconst SVGElements = new Set([\n\"altGlyph\", \"altGlyphDef\", \"altGlyphItem\", \"animate\", \"animateColor\", \"animateMotion\", \"animateTransform\", \"circle\", \"clipPath\", \"color-profile\", \"cursor\", \"defs\", \"desc\", \"ellipse\", \"feBlend\", \"feColorMatrix\", \"feComponentTransfer\", \"feComposite\", \"feConvolveMatrix\", \"feDiffuseLighting\", \"feDisplacementMap\", \"feDistantLight\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feImage\", \"feMerge\", \"feMergeNode\", \"feMorphology\", \"feOffset\", \"fePointLight\", \"feSpecularLighting\", \"feSpotLight\", \"feTile\", \"feTurbulence\", \"filter\", \"font\", \"font-face\", \"font-face-format\", \"font-face-name\", \"font-face-src\", \"font-face-uri\", \"foreignObject\", \"g\", \"glyph\", \"glyphRef\", \"hkern\", \"image\", \"line\", \"linearGradient\", \"marker\", \"mask\", \"metadata\", \"missing-glyph\", \"mpath\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialGradient\", \"rect\",\n\"set\", \"stop\",\n\"svg\", \"switch\", \"symbol\", \"text\", \"textPath\",\n\"tref\", \"tspan\", \"use\", \"view\", \"vkern\"]);\nconst SVGNamespace = {\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\"\n};\n\nfunction memo(fn, equals) {\n  return createMemo(fn, undefined, !equals ? {\n    equals\n  } : undefined);\n}\n\nfunction reconcileArrays(parentNode, a, b) {\n  let bLength = b.length,\n      aEnd = a.length,\n      bEnd = bLength,\n      aStart = 0,\n      bStart = 0,\n      after = a[aEnd - 1].nextSibling,\n      map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n    while (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;\n      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a[aStart])) parentNode.removeChild(a[aStart]);\n        aStart++;\n      }\n    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      const node = a[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n        while (i < bEnd) map.set(b[i], i++);\n      }\n      const index = map.get(a[aStart]);\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i = aStart,\n              sequence = 1,\n              t;\n          while (++i < aEnd && i < bEnd) {\n            if ((t = map.get(a[i])) == null || t !== index + sequence) break;\n            sequence++;\n          }\n          if (sequence > index - bStart) {\n            const node = a[aStart];\n            while (bStart < index) parentNode.insertBefore(b[bStart++], node);\n          } else parentNode.replaceChild(b[bStart++], a[aStart++]);\n        } else aStart++;\n      } else parentNode.removeChild(a[aStart++]);\n    }\n  }\n}\n\nconst $$EVENTS = \"_$DX_DELEGATE\";\nfunction render(code, element, init) {\n  let disposer;\n  createRoot(dispose => {\n    disposer = dispose;\n    insert(element, code(), element.firstChild ? null : undefined, init);\n  });\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\nfunction template(html, check, isSVG) {\n  const t = document.createElement(\"template\");\n  t.innerHTML = html;\n  let node = t.content.firstChild;\n  if (isSVG) node = node.firstChild;\n  return node;\n}\nfunction delegateEvents(eventNames, document = window.document) {\n  const e = document[$$EVENTS] || (document[$$EVENTS] = new Set());\n  for (let i = 0, l = eventNames.length; i < l; i++) {\n    const name = eventNames[i];\n    if (!e.has(name)) {\n      e.add(name);\n      document.addEventListener(name, eventHandler);\n    }\n  }\n}\nfunction clearDelegatedEvents(document = window.document) {\n  if (document[$$EVENTS]) {\n    for (let name of document[$$EVENTS].keys()) document.removeEventListener(name, eventHandler);\n    delete document[$$EVENTS];\n  }\n}\nfunction setAttribute(node, name, value) {\n  if (value == null) node.removeAttribute(name);else node.setAttribute(name, value);\n}\nfunction setAttributeNS(node, namespace, name, value) {\n  if (value == null) node.removeAttributeNS(namespace, name);else node.setAttributeNS(namespace, name, value);\n}\nfunction addEventListener(node, name, handler, delegate) {\n  if (delegate) {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else node[`$$${name}`] = handler;\n  } else if (Array.isArray(handler)) {\n    node.addEventListener(name, e => handler[0](handler[1], e));\n  } else node.addEventListener(name, handler);\n}\nfunction classList(node, value, prev = {}) {\n  const classKeys = Object.keys(value),\n        prevKeys = Object.keys(prev);\n  let i, len;\n  for (i = 0, len = prevKeys.length; i < len; i++) {\n    const key = prevKeys[i];\n    if (!key || key === \"undefined\" || key in value) continue;\n    toggleClassKey(node, key, false);\n    delete prev[key];\n  }\n  for (i = 0, len = classKeys.length; i < len; i++) {\n    const key = classKeys[i],\n          classValue = !!value[key];\n    if (!key || key === \"undefined\" || prev[key] === classValue) continue;\n    toggleClassKey(node, key, classValue);\n    prev[key] = classValue;\n  }\n  return prev;\n}\nfunction style(node, value, prev = {}) {\n  const nodeStyle = node.style;\n  if (typeof value === \"string\") return nodeStyle.cssText = value;\n  typeof prev === \"string\" && (prev = {});\n  let v, s;\n  for (s in prev) {\n    value[s] == null && nodeStyle.removeProperty(s);\n    delete prev[s];\n  }\n  for (s in value) {\n    v = value[s];\n    if (v !== prev[s]) {\n      nodeStyle.setProperty(s, v);\n      prev[s] = v;\n    }\n  }\n  return prev;\n}\nfunction spread(node, accessor, isSVG, skipChildren) {\n  if (typeof accessor === \"function\") {\n    createRenderEffect(current => spreadExpression(node, accessor(), current, isSVG, skipChildren));\n  } else spreadExpression(node, accessor, undefined, isSVG, skipChildren);\n}\nfunction dynamicProperty(props, key) {\n  const src = props[key];\n  Object.defineProperty(props, key, {\n    get() {\n      return src();\n    },\n    enumerable: true\n  });\n  return props;\n}\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== undefined && !initial) initial = [];\n  if (typeof accessor !== \"function\") return insertExpression(parent, accessor, initial, marker);\n  createRenderEffect(current => insertExpression(parent, accessor(), current, marker), initial);\n}\nfunction assign(node, props, isSVG, skipChildren, prevProps = {}) {\n  let isCE, isProp, isChildProp;\n  for (const prop in props) {\n    if (prop === \"children\") {\n      if (!skipChildren) insertExpression(node, props.children);\n      continue;\n    }\n    const value = props[prop];\n    if (value === prevProps[prop]) continue;\n    if (prop === \"style\") {\n      style(node, value, prevProps[prop]);\n    } else if (prop === \"class\" && !isSVG) {\n      node.className = value;\n    } else if (prop === \"classList\") {\n      classList(node, value, prevProps[prop]);\n    } else if (prop === \"ref\") {\n      value(node);\n    } else if (prop.slice(0, 3) === \"on:\") {\n      node.addEventListener(prop.slice(3), value);\n    } else if (prop.slice(0, 10) === \"oncapture:\") {\n      node.addEventListener(prop.slice(10), value, true);\n    } else if (prop.slice(0, 2) === \"on\") {\n      const name = prop.slice(2).toLowerCase();\n      const delegate = DelegatedEvents.has(name);\n      addEventListener(node, name, value, delegate);\n      delegate && delegateEvents([name]);\n    } else if ((isChildProp = ChildProperties.has(prop)) || !isSVG && (isProp = Properties.has(prop)) || (isCE = node.nodeName.includes(\"-\"))) {\n      if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;else node[prop] = value;\n    } else {\n      const ns = isSVG && prop.indexOf(\":\") > -1 && SVGNamespace[prop.split(\":\")[0]];\n      if (ns) setAttributeNS(node, ns, prop, value);else setAttribute(node, Aliases[prop] || prop, value);\n    }\n    prevProps[prop] = value;\n  }\n}\nfunction hydrate(code, element) {\n  sharedConfig.resources = globalThis._$HYDRATION.resources;\n  sharedConfig.completed = globalThis._$HYDRATION.completed;\n  sharedConfig.events = globalThis._$HYDRATION.events;\n  sharedConfig.context = {\n    id: \"\",\n    count: 0,\n    loadResource: globalThis._$HYDRATION.loadResource\n  };\n  sharedConfig.registry = new Map();\n  gatherHydratable(element);\n  const dispose = render(code, element, [...element.childNodes]);\n  sharedConfig.context = null;\n  return dispose;\n}\nfunction gatherHydratable(element) {\n  const templates = element.querySelectorAll(`*[data-hk]`);\n  for (let i = 0; i < templates.length; i++) {\n    const node = templates[i];\n    sharedConfig.registry.set(node.getAttribute(\"data-hk\"), node);\n  }\n}\nfunction getNextElement(template) {\n  let node, key;\n  if (!sharedConfig.context || !(node = sharedConfig.registry.get(key = getHydrationKey()))) {\n    return template.cloneNode(true);\n  }\n  if (sharedConfig.completed) sharedConfig.completed.add(node);\n  sharedConfig.registry.delete(key);\n  return node;\n}\nfunction getNextMatch(el, nodeName) {\n  while (el && el.localName !== nodeName) el = el.nextSibling;\n  return el;\n}\nfunction getNextMarker(start) {\n  let end = start,\n      count = 0,\n      current = [];\n  if (sharedConfig.context) {\n    while (end) {\n      if (end.nodeType === 8) {\n        const v = end.nodeValue;\n        if (v === \"#\") count++;else if (v === \"/\") {\n          if (count === 0) return [end, current];\n          count--;\n        }\n      }\n      current.push(end);\n      end = end.nextSibling;\n    }\n  }\n  return [end, current];\n}\nfunction runHydrationEvents() {\n  if (sharedConfig.events && !sharedConfig.events.queued) {\n    queueMicrotask(() => {\n      const {\n        completed,\n        events\n      } = sharedConfig;\n      events.queued = false;\n      while (events.length) {\n        const [el, e] = events[0];\n        if (!completed.has(el)) return;\n        eventHandler(e);\n        events.shift();\n      }\n    });\n    sharedConfig.events.queued = true;\n  }\n}\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\nfunction toggleClassKey(node, key, value) {\n  const classNames = key.trim().split(/\\s+/);\n  for (let i = 0, nameLen = classNames.length; i < nameLen; i++) node.classList.toggle(classNames[i], value);\n}\nfunction eventHandler(e) {\n  const key = `$$${e.type}`;\n  let node = e.composedPath && e.composedPath()[0] || e.target;\n  if (e.target !== node) {\n    Object.defineProperty(e, \"target\", {\n      configurable: true,\n      value: node\n    });\n  }\n  Object.defineProperty(e, \"currentTarget\", {\n    configurable: true,\n    get() {\n      return node;\n    }\n  });\n  while (node !== null) {\n    const handler = node[key];\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== undefined ? handler(data, e) : handler(e);\n      if (e.cancelBubble) return;\n    }\n    node = node.host && node.host !== node && node.host instanceof Node ? node.host : node.parentNode;\n  }\n}\nfunction spreadExpression(node, props, prevProps = {}, isSVG, skipChildren) {\n  if (!skipChildren && \"children\" in props) {\n    createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));\n  }\n  createRenderEffect(() => assign(node, props, isSVG, true, prevProps));\n  return prevProps;\n}\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  while (typeof current === \"function\") current = current();\n  if (value === current) return current;\n  const t = typeof value,\n        multi = marker !== undefined;\n  parent = multi && current[0] && current[0].parentNode || parent;\n  if (t === \"string\" || t === \"number\") {\n    if (t === \"number\") value = value.toString();\n    if (multi) {\n      let node = current[0];\n      if (node && node.nodeType === 3) {\n        node.data = value;\n      } else node = document.createTextNode(value);\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t === \"boolean\") {\n    if (sharedConfig.context) return current;\n    current = cleanChildren(parent, current, marker);\n  } else if (t === \"function\") {\n    createRenderEffect(() => {\n      let v = value();\n      while (typeof v === \"function\") v = v();\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n    if (normalizeIncomingArray(array, value, unwrapArray)) {\n      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));\n      return () => current;\n    }\n    if (sharedConfig.context && current.length) return current;\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi) return current;\n    } else {\n      if (Array.isArray(current)) {\n        if (current.length === 0) {\n          appendNodes(parent, array, marker);\n        } else reconcileArrays(parent, current, array);\n      } else if (current == null || current === \"\") {\n        appendNodes(parent, array);\n      } else {\n        reconcileArrays(parent, multi && current || [parent.firstChild], array);\n      }\n    }\n    current = array;\n  } else if (value instanceof Node) {\n    if (Array.isArray(current)) {\n      if (multi) return current = cleanChildren(parent, current, marker, value);\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else parent.replaceChild(value, parent.firstChild);\n    current = value;\n  } else ;\n  return current;\n}\nfunction normalizeIncomingArray(normalized, array, unwrap) {\n  let dynamic = false;\n  for (let i = 0, len = array.length; i < len; i++) {\n    let item = array[i],\n        t;\n    if (item instanceof Node) {\n      normalized.push(item);\n    } else if (item == null || item === true || item === false) ; else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item) || dynamic;\n    } else if ((t = typeof item) === \"string\") {\n      normalized.push(document.createTextNode(item));\n    } else if (t === \"function\") {\n      if (unwrap) {\n        while (typeof item === \"function\") item = item();\n        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item]) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else normalized.push(document.createTextNode(item.toString()));\n  }\n  return dynamic;\n}\nfunction appendNodes(parent, array, marker) {\n  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);\n}\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === undefined) return parent.textContent = \"\";\n  const node = replacement || document.createTextNode(\"\");\n  if (current.length) {\n    let inserted = false;\n    for (let i = current.length - 1; i >= 0; i--) {\n      const el = current[i];\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);else isParent && parent.removeChild(el);\n      } else inserted = true;\n    }\n  } else parent.insertBefore(node, marker);\n  return [node];\n}\nfunction getHydrationKey() {\n  const hydrate = sharedConfig.context;\n  return `${hydrate.id}${hydrate.count++}`;\n}\nfunction Assets() {\n  return;\n}\nfunction NoHydration(props) {\n  return sharedConfig.context ? undefined : props.children;\n}\n\nfunction renderToString(fn, options) {}\nfunction renderToStringAsync(fn, options) {}\nfunction pipeToNodeWritable(fn, writable, options) {}\nfunction pipeToWritable(fn, writable, options) {}\nfunction ssr(template, ...nodes) {}\nfunction resolveSSRNode(node) {}\nfunction ssrClassList(value) {}\nfunction ssrStyle(value) {}\nfunction ssrSpread(accessor) {}\nfunction ssrBoolean(key, value) {}\nfunction ssrHydrationKey() {}\nfunction escape(html) {}\nfunction generateHydrationScript() {}\n\nconst isServer = false;\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nfunction createElement(tagName, isSVG = false) {\n  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);\n}\nfunction Portal(props) {\n  const {\n    useShadow\n  } = props,\n        marker = document.createTextNode(\"\"),\n        mount = props.mount || document.body;\n  function renderPortal() {\n    if (sharedConfig.context) {\n      const [s, set] = createSignal(false);\n      queueMicrotask(() => set(true));\n      return () => s() && props.children;\n    } else return () => props.children;\n  }\n  if (mount instanceof HTMLHeadElement) {\n    const [clean, setClean] = createSignal(false);\n    const cleanup = () => setClean(true);\n    createRoot(dispose => insert(mount, () => !clean() ? renderPortal()() : dispose(), null));\n    onCleanup(() => {\n      if (sharedConfig.context) queueMicrotask(cleanup);else cleanup();\n    });\n  } else {\n    const container = createElement(props.isSVG ? \"g\" : \"div\", props.isSVG),\n          renderRoot = useShadow && container.attachShadow ? container.attachShadow({\n      mode: \"open\"\n    }) : container;\n    Object.defineProperty(container, \"host\", {\n      get() {\n        return marker.parentNode;\n      }\n    });\n    insert(renderRoot, renderPortal());\n    mount.appendChild(container);\n    props.ref && props.ref(container);\n    onCleanup(() => mount.removeChild(container));\n  }\n  return marker;\n}\nfunction Dynamic(props) {\n  const [p, others] = splitProps(props, [\"component\"]);\n  return createMemo(() => {\n    const component = p.component;\n    switch (typeof component) {\n      case \"function\":\n        return untrack(() => component(others));\n      case \"string\":\n        const isSvg = SVGElements.has(component);\n        const el = createElement(component, isSvg);\n        spread(el, others, isSvg);\n        return el;\n    }\n  });\n}\n\nexport { Aliases, Assets, ChildProperties, DelegatedEvents, Dynamic, Assets as HydrationScript, NoHydration, Portal, Properties, SVGElements, SVGNamespace, addEventListener, assign, classList, clearDelegatedEvents, delegateEvents, dynamicProperty, escape, gatherHydratable, generateHydrationScript, getHydrationKey, getNextElement, getNextMarker, getNextMatch, hydrate, insert, isServer, memo, pipeToNodeWritable, pipeToWritable, render, renderToString, renderToStringAsync, resolveSSRNode, runHydrationEvents, setAttribute, setAttributeNS, spread, ssr, ssrBoolean, ssrClassList, ssrHydrationKey, ssrSpread, ssrStyle, style, template };\n","import { createMemo, JSX, untrack } from \"solid-js\";\n\nexport function ShowBool(props: {\n    when: boolean,\n    fallback?: JSX.Element,\n    children: JSX.Element,\n}): JSX.Element {\n    const condition = createMemo(() => props.when, undefined, {\n        equals: (a: boolean, b: boolean) => !a === !b,\n    });\n    return createMemo(() => {\n        if(condition()) return props.children;\n        return props.fallback;\n    });\n}\nexport function ShowCond<T>(props: {\n    when: T | undefined | null,\n    fallback?: JSX.Element,\n    children: (item: T) => JSX.Element,\n}): JSX.Element {\n    return createMemo(() => {\n        if (props.when != null) {\n            const child = props.children;\n            return untrack(() => child(props.when!));\n        }\n        return props.fallback;\n    });\n}\n\nexport type Include<T, U> = T extends U ? T : never;\n\nexport function kindIs<K extends string, T extends {kind: string}>(value: T, key: K): Include<T, {kind: K}> | null {\n    return value.kind === key ? value as unknown as null : null;\n}\n\ntype MatchFn<T, Key> = (value: Include<T, {kind: Key}>) => JSX.Element;\nexport function SwitchKind<T extends {kind: string}>(props: {\n    item: T,\n    children: {[Key in T[\"kind\"]]: MatchFn<T, Key>},\n}): JSX.Element {\n    // <Switch children={/*@once*/} />\n    return createMemo(() => {\n        let match = props.children[props.item.kind as T[\"kind\"]] as MatchFn<T, T[\"kind\"]> | undefined;\n        if(!match) {\n            match = props.children[\"unsupported\" as T[\"kind\"]] as MatchFn<T, T[\"kind\"]> | undefined;\n            if(!match) throw new Error(\"condition \"+props.item.kind+\" was not handled and no unsupported branch\");\n        }\n        const arg = props.item as Include<T, {kind: T[\"kind\"]}>;\n        return untrack(() => match!(arg)); // untrack in order to treat the function as a widget (dependencies accessed don't cause this to reexec)\n    });\n}","import { ShowBool, ShowCond, SwitchKind } from \"./utils\";\nimport { createContext, createMemo, createSignal, JSX, untrack, useContext } from \"solid-js\";\nimport {render} from \"solid-js/web\";\nimport \"virtual:windi.css\";\nimport \"./disabled.css\";\n\nif(location.pathname.endsWith(\"-dev.html\")) {\n    fetch(\"http://localhost:8020/bundle.css\").then(r => r.text()).then(css => {\n        const style = document.createElement(\"style\");\n        style.textContent = css;\n        document.head.appendChild(style);\n    });\n}\n\nconst query = new URLSearchParams(location.search);\n\nlet meta_id = \"ENOID\";\n\nfunction libPath(id: LibID) {\n    if(location.pathname.endsWith(\"-dev.html\")) {\n        return \"/mirodnd/app-dev.html?page=\"+encodeURIComponent(id);\n    }else{\n        return \"/mirodnd/app.html?page=\"+encodeURIComponent(id);\n    }\n}\nfunction fullLibPath(id: LibID) {\n    return \"https://pfg.pw\"+libPath(id);\n}\n\ntype DiceMeta = {\n    kind: \"random\",\n    min: number,\n    max: number,\n};\ntype Metadata = DiceMeta | {\n    kind: \"frame_link\",\n    frame_id: string,\n    create_back_button?: boolean,\n} | {\n    kind: \"back_link\",\n    viewport: SDK.IRect,\n} | {\n    kind: \"unsupported\",\n};\n\nconst page = query.get(\"page\") as LibID | null;\n\ntype LibID = \"side_panel\" | \"unsupported\";\n\nasync function createCentered(): Promise<{x: number, y: number, width: number, height: number}> {\n    const frame = await miro.board.viewport.get();\n    const size = Math.min(frame.width / 10, frame.height / 10);\n    return {\n        x: frame.x + (frame.width / 2),\n        y: frame.y + (frame.height / 2),\n        width: size,\n        height: size,\n    };\n}\n\nfunction randomizeDice(meta: DiceMeta): string {\n    const randv = (((Math.random() * ((meta.max + 1) - meta.min)) |0) + meta.min);\n    if(meta.min === 1 && meta.max === 6) {\n        return [...\"⚀⚁⚂⚃⚄⚅\"][randv - 1]!;\n    }else if(meta.min === 1) {\n        return \"d\"+meta.max+\": \"+randv;\n    }\n    return \"Num: \"+randv;\n}\n\nasync function activateSelectedItem(selection: SDK.IWidget[]): Promise<undefined | {activated: false}> {\n    if(selection.length !== 1) return {activated: false};\n    const selxitm = selection[0]!;\n    const meta = selxitm.metadata[meta_id] as Metadata | undefined;\n    if(!meta) return {activated: false};\n\n    if(meta.kind === \"random\") {\n        const [widget] = await miro.board.widgets.get({id: selxitm.id, type: \"STICKER\"}) as [SDK.ITextWidget | undefined];\n        if(!widget) return void miro.showErrorNotification(\"dice error. try making new dice.\");\n\n        widget.text = randomizeDice(meta);\n\n        await miro.board.widgets.update(widget);\n\n        return;\n    }else if(meta.kind === \"frame_link\") {\n        const [frame] = await miro.board.widgets.get({id: meta.frame_id, type: \"FRAME\"}) as [SDK.IFrameWidget | undefined];\n        if(!frame) return void miro.showErrorNotification(\"link error. maybe the link was deleted? try making a new link\");\n        \n        const prev_viewport = await miro.board.viewport.get();\n        await miro.board.viewport.set({x: frame.x - (frame.width / 2), y: frame.y - (frame.height / 2), width: frame.width, height: frame.height});\n        \n        if(meta.create_back_button ?? true) {\n            const backmeta: Metadata = {\n                kind: \"back_link\",\n                viewport: {\n                    x: prev_viewport.x,\n                    y: prev_viewport.y,\n                    width: prev_viewport.width,\n                    height: prev_viewport.height,\n                },\n            };\n            const backbtnsize = Math.min(frame.width / 10, frame.height / 10);\n            const backbtnw = backbtnsize;\n            const backbtnh = backbtnsize / 3;\n            await miro.board.widgets.create({\n                type: 'shape',\n                text: '< Back',\n                x: frame.x - (frame.width / 2) + (backbtnw / 2),\n                y: frame.y - (frame.height / 2) + (backbtnh / 2),\n                width: backbtnw,\n                height: backbtnh,\n                metadata: {\n                    [meta_id]: backmeta,\n                },\n            });\n        }\n\n        return;\n    }else if(meta.kind === \"back_link\") {\n        await miro.board.viewport.set(meta.viewport);\n        await miro.board.widgets.deleteById(selxitm.id);\n\n        return;\n    }\n\n    void miro.showErrorNotification(\"error, unsupported kind \"+meta.kind);\n    return;\n}\n\nfunction NoSelection(): JSX.Element {\n    return <div>\n        <button class=\"btn\" onClick={async () => {\n            const meta: Metadata = {\n                kind: \"random\",\n                min: 1,\n                max: 20,\n            };\n            await miro.board.widgets.create({\n                type: 'sticker',\n                text: 'Click to Roll',\n                ...await createCentered(), metadata: {\n                    [meta_id]: meta,\n                },\n            });\n        // woah widget.clientVisible\n        }}>Create D20</button>\n        <button class=\"btn\" onClick={async () => {\n            const selected_items = await miro.board.selection.get();\n            if(selected_items.length !== 1) return void miro.showErrorNotification(\"select frame then click\");\n            const selected = selected_items[0]!;\n            if(selected.type !== \"FRAME\") return void miro.showErrorNotification(\"need frame\");\n\n            const meta: Metadata = {\n                kind: \"frame_link\",\n                frame_id: selected.id,\n            };\n            await miro.board.widgets.create({type: 'sticker', text: 'Jump', ...await createCentered(), metadata: {\n                [meta_id]: meta,\n            }});\n        }}>Create link to frame</button>\n        <button class=\"btn\" onClick={async () => {\n            await miro.board.widgets.create({\n                type: \"embed\",\n                ...await createCentered(),\n                html: \"<iframe src=\\\"\"+fullLibPath(\"unsupported\")+\"\\\"></iframe>\",\n            });\n        }}>Create thing</button>\n        <div>\n            Click Mode:\n            <button class=\"btn\" onClick={() => {\n                localStorage.setItem(\"cfg-clickmode\", \"click\");\n            }}>Click</button>\n            <button class=\"btn\" onClick={() => {\n                localStorage.setItem(\"cfg-clickmode\", \"instant\");\n            }}>Instant</button>\n        </div>\n    </div>;\n}\n\nfunction SelectionEditor(props: {selection: SelectionState}): JSX.Element {\n    return <div>\n        <button class=\"btn\" onclick={async () => {\n            await activateSelectedItem([props.selection.widget]);\n        }}>○ Activate</button>\n        <SwitchKind item={props.selection.meta}>{{\n            random: meta => {\n                const [state, setState] = createSignal<DiceMeta>({...meta});\n\n                return <div>\n                    <h1 class=\"heading\">Dice</h1>\n                    <div><label>Min: <input\n                        class=\"input\"\n                        onInput={e => setState(d => ({...d, min: +e.currentTarget.value}))}\n                        type=\"number\"\n                        ref={el => el.value = \"\" + state().min}\n                    /></label></div>\n                    <div><label>Max: <input\n                        class=\"input\"\n                        onInput={e => setState(d => ({...d, max: +e.currentTarget.value}))}\n                        type=\"number\"\n                        ref={el => el.value = \"\" + state().max}\n                    /></label></div>\n                    <button class=\"btn\"\n                        disabled={JSON.stringify(state()) === JSON.stringify(meta)}\n                        onClick={async () => {\n                            Object.assign(meta, state());\n                            (props.selection.widget as SDK.IStickerWidget).text = randomizeDice(meta);\n                            await miro.board.widgets.update(props.selection.widget);\n                            setState({...meta});\n                        }}\n                    >Save</button>\n                </div>;\n            },\n            frame_link: meta => {\n                const [state, setState] = createSignal({...meta});\n\n                return <div>\n                    <h1 class=\"heading\">Frame Link</h1>\n                    <div>Link to: [TODO]</div>\n                    <div><label><input\n                        onInput={e => setState(d => ({...d, create_back_button: !(d.create_back_button ?? true)}))}\n                        type=\"checkbox\"\n                        checked={state().create_back_button ?? true}\n                    /> Make back button</label></div>\n                    <button class=\"btn\"\n                        disabled={JSON.stringify(state()) === JSON.stringify(meta)}\n                        onClick={async () => {\n                            Object.assign(meta, state());\n                            await miro.board.widgets.update(props.selection.widget);\n                            setState({...meta});\n                        }}\n                    >Save</button>\n                </div>;\n            },\n            back_link: meta => <div>not editable</div>,\n            unsupported: meta => <div>\n                TODO edit {meta.kind}\n            </div>,\n        }}</SwitchKind>\n    </div>;\n}\n\ntype SelectionState = {widget: SDK.IWidget, meta: Metadata};\nfunction SidePanel(props: {selection: SelectionState | null}): JSX.Element {\n    // <button class=\"btn\" onClick={() => location.reload()}>Refresh Panel</button>\n    return <div>\n        <ShowCond when={props.selection} fallback={<NoSelection />}>{selxn => (\n            <SelectionEditor selection={selxn} />\n        )}</ShowCond>\n    </div>;\n}\n\nfunction runSidePanel() {\n\n    const [selection, setSelection] = createSignal<SelectionState | null>(null);\n    const sp = document.createElement(\"div\");\n    document.body.appendChild(sp);\n    render(() => <SidePanel selection={selection()} />, sp);\n\n    miro.addListener(\"SELECTION_UPDATED\", async (event) => {\n        const data = event.data as {id: string, metadata: {[key: string]: unknown}, type: string}[];\n        if(data.length !== 1) return setSelection(null);\n        const selxitm = data[0]!;\n        const meta = selxitm.metadata[meta_id] as Metadata | undefined;\n        if(!meta) return setSelection(null);\n\n        const selection = await miro.board.widgets.get({id: selxitm.id});\n        if(selection.length !== 1) return setSelection(null);\n        const wselxitm = selection[0]!;\n\n        const wmeta = wselxitm.metadata[meta_id] as Metadata | undefined;        \n        if(!wmeta) return setSelection(null);\n        setSelection({widget: wselxitm, meta: wmeta});\n    });\n}\nfunction runMainScreen() {\n    document.body.appendChild(document.createTextNode(\"You should not be seeing this.\"));\n\n    // const icon24 = '<path fill=\"currentColor\" fill-rule=\"nonzero\" d=\"M20.156 7.762c-1.351-3.746-4.672-5.297-8.838-4.61-'\n    // +'3.9.642-7.284 3.15-7.9 5.736-1.14 4.784-.015 7.031 2.627 8.09.61.244 1.28.412 2.002.518.277.041.549.072.844.097.1'\n    // +'38.012.576.045.659.053.109.01.198.02.291.035 1.609.263 2.664 1.334 3.146 2.715 7.24-2.435 9.4-6.453 7.17-12.634zm'\n    // +'-18.684.662C3.18 1.256 18.297-3.284 22.038 7.084c2.806 7.78-.526 13.011-9.998 15.695-.266.076-.78.173-.759-.287.0'\n    // +'62-1.296-.47-2.626-1.762-2.837-1.009-.165-10.75.124-8.047-11.23zm9.427 4.113a6.853 6.853 0 0 0 1.787.172c.223.348'\n    // +'.442.733.79 1.366.53.967.793 1.412 1.206 2a1 1 0 1 0 1.636-1.15c-.358-.51-.593-.908-1.09-1.812-.197-.36-.358-.649'\n    // +'-.503-.899 1.16-.573 1.916-1.605 2.005-2.909.189-2.748-2.65-4.308-6.611-3.267-.443.117-.834.44-.886 1.408-.065 1.'\n    // +'192-.12 2.028-.25 3.825-.129 1.808-.185 2.653-.25 3.86a1 1 0 0 0 1.997.108c.05-.913.093-1.617.17-2.702zm.144-2.02'\n    // +'6c.077-1.106.124-1.82.171-2.675 2.398-.483 3.595.257 3.521 1.332-.08 1.174-1.506 1.965-3.692 1.343z\"/>';\n\n    const circle_icon = '<circle cx=\"12\" cy=\"12\" r=\"9\" fill=\"none\" fill-rule=\"evenodd\" stroke=\"currentColor\" stroke-width=\"2\"/>';\n\n    miro.onReady(() => {\n        miro.initialize({\n            extensionPoints: {\n                bottomBar: {\n                    title: 'R🙲O',\n                    svgIcon: circle_icon,\n                    onClick: async () => {\n                        const is_authorized = await miro.isAuthorized();\n                        if(!is_authorized) {\n                            await miro.requestAuthorization();\n                        }\n\n                        if((localStorage.getItem(\"cfg-clickmode\") ?? \"click\") === \"click\") {\n                            const selection = await miro.board.selection.get();\n                            if(!await activateSelectedItem(selection)) return;\n                        }\n\n                        await miro.board.ui.openLeftSidebar(libPath(\"side_panel\"));\n                    }\n                }\n            },\n        }).catch(e => console.log(\"plugin init error\", e));\n\n        miro.addListener(\"SELECTION_UPDATED\", async (event) => {\n            const data = event.data as {id: string, metadata: {[key: string]: unknown}, type: string}[];\n            if(data.length !== 1) return;\n            const selxitm = data[0]!;\n            const meta = selxitm.metadata[meta_id] as Metadata | undefined;\n            if(!meta) return;\n\n            if(localStorage.getItem(\"cfg-clickmode\") !== \"instant\") {\n                void miro.showNotification(\"Click the circle button to activate.\");\n                return;\n            }\n\n            const selection = await miro.board.widgets.get({id: selxitm.id});\n            await activateSelectedItem(selection);\n        });\n    });\n}\n\nfunction doStart() {\n    if(page === \"side_panel\") {\n        runSidePanel();\n    }else if(page == null){\n        runMainScreen();\n    }else{\n        document.body.appendChild(document.createTextNode(\"404 not found page: \"+page));\n    }\n}\n\nif(!(miro.onReady as unknown as boolean)) {\n    doStart();\n}else miro.onReady(() => {\n    meta_id = miro.getClientId();\n\n    doStart();\n});"],"names":["signalOptions","equals","a","b","runEffects","runQueue","NOTPENDING","UNOWNED","owned","cleanups","context","owner","Owner","Transition","Listener","Pending","Updates","Effects","ExecCount","createSignal","value","options","Object","assign","s","observers","observerSlots","pending","comparator","undefined","readSignal","bind","writeSignal","createRenderEffect","fn","updateComputation","createComputation","createMemo","c","state","untrack","result","listener","this","sources","updates","lookDownstream","sSlot","length","push","sourceSlots","node","isComp","runUpdates","i","o","markUpstream","pure","Error","cleanNode","time","nextValue","err","handleError","updatedAt","runComputation","init","runTop","top","suspense","inFallback","effects","wait","q","data","batch","completeUpdates","queue","source","pop","index","obs","n","createComponent","Comp","props","reconcileArrays","parentNode","bLength","aEnd","bEnd","aStart","bStart","after","nextSibling","map","insertBefore","has","removeChild","Map","set","get","t","sequence","replaceChild","$$EVENTS","render","code","element","disposer","detachedOwner","root","createRoot","dispose","insert","firstChild","textContent","template","html","check","isSVG","document","createElement","innerHTML","content","parent","accessor","marker","initial","insertExpression","current","eventHandler","e","key","type","composedPath","target","defineProperty","configurable","handler","disabled","cancelBubble","host","Node","unwrapArray","multi","toString","nodeType","createTextNode","cleanChildren","v","Array","isArray","array","normalizeIncomingArray","appendNodes","appendChild","normalized","unwrap","dynamic","len","item","replacement","inserted","el","isParent","ShowCond","when","child","children","fallback","SwitchKind","match","kind","arg","location","pathname","endsWith","fetch","then","r","text","css","style","head","query","URLSearchParams","search","meta_id","libPath","id","encodeURIComponent","page","async","createCentered","frame","miro","board","viewport","size","Math","min","width","height","x","y","randomizeDice","meta","randv","random","max","activateSelectedItem","selection","activated","selxitm","metadata","widget","widgets","update","showErrorNotification","deleteById","frame_id","prev_viewport","create_back_button","backmeta","backbtnsize","backbtnw","backbtnh","create","NoSelection","selected_items","selected","localStorage","setItem","SelectionEditor","setState","d","currentTarget","JSON","stringify","frame_link","back_link","unsupported","SidePanel","selxn","doStart","setSelection","sp","body","addListener","event","wselxitm","wmeta","runSidePanel","onReady","initialize","extensionPoints","bottomBar","title","svgIcon","onClick","isAuthorized","requestAuthorization","getItem","ui","openLeftSidebar","catch","console","log","showNotification","getClientId","eventNames","window","Set","l","name","add","addEventListener"],"mappings":"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"}